// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'score_input_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$ScoreInputState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function(UserFinancialData data) loading,
    required TResult Function(
      UserFinancialData data,
      bool hasError,
      bool isAnnualIncomeInvalid,
      bool isMonthlyCostsIinvalid,
    )
    failed,
    required TResult Function(FinancialWellnessScore score) completed,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function(UserFinancialData data)? loading,
    TResult? Function(
      UserFinancialData data,
      bool hasError,
      bool isAnnualIncomeInvalid,
      bool isMonthlyCostsIinvalid,
    )?
    failed,
    TResult? Function(FinancialWellnessScore score)? completed,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function(UserFinancialData data)? loading,
    TResult Function(
      UserFinancialData data,
      bool hasError,
      bool isAnnualIncomeInvalid,
      bool isMonthlyCostsIinvalid,
    )?
    failed,
    TResult Function(FinancialWellnessScore score)? completed,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScoreInputInitialState value) idle,
    required TResult Function(ScoreInputLoading value) loading,
    required TResult Function(ScoreCalculationFailed value) failed,
    required TResult Function(ScoreCompleted value) completed,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ScoreInputInitialState value)? idle,
    TResult? Function(ScoreInputLoading value)? loading,
    TResult? Function(ScoreCalculationFailed value)? failed,
    TResult? Function(ScoreCompleted value)? completed,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScoreInputInitialState value)? idle,
    TResult Function(ScoreInputLoading value)? loading,
    TResult Function(ScoreCalculationFailed value)? failed,
    TResult Function(ScoreCompleted value)? completed,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ScoreInputStateCopyWith<$Res> {
  factory $ScoreInputStateCopyWith(
    ScoreInputState value,
    $Res Function(ScoreInputState) then,
  ) = _$ScoreInputStateCopyWithImpl<$Res, ScoreInputState>;
}

/// @nodoc
class _$ScoreInputStateCopyWithImpl<$Res, $Val extends ScoreInputState>
    implements $ScoreInputStateCopyWith<$Res> {
  _$ScoreInputStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ScoreInputState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ScoreInputInitialStateImplCopyWith<$Res> {
  factory _$$ScoreInputInitialStateImplCopyWith(
    _$ScoreInputInitialStateImpl value,
    $Res Function(_$ScoreInputInitialStateImpl) then,
  ) = __$$ScoreInputInitialStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ScoreInputInitialStateImplCopyWithImpl<$Res>
    extends _$ScoreInputStateCopyWithImpl<$Res, _$ScoreInputInitialStateImpl>
    implements _$$ScoreInputInitialStateImplCopyWith<$Res> {
  __$$ScoreInputInitialStateImplCopyWithImpl(
    _$ScoreInputInitialStateImpl _value,
    $Res Function(_$ScoreInputInitialStateImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ScoreInputState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ScoreInputInitialStateImpl extends ScoreInputInitialState {
  _$ScoreInputInitialStateImpl() : super._();

  @override
  String toString() {
    return 'ScoreInputState.idle()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ScoreInputInitialStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function(UserFinancialData data) loading,
    required TResult Function(
      UserFinancialData data,
      bool hasError,
      bool isAnnualIncomeInvalid,
      bool isMonthlyCostsIinvalid,
    )
    failed,
    required TResult Function(FinancialWellnessScore score) completed,
  }) {
    return idle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function(UserFinancialData data)? loading,
    TResult? Function(
      UserFinancialData data,
      bool hasError,
      bool isAnnualIncomeInvalid,
      bool isMonthlyCostsIinvalid,
    )?
    failed,
    TResult? Function(FinancialWellnessScore score)? completed,
  }) {
    return idle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function(UserFinancialData data)? loading,
    TResult Function(
      UserFinancialData data,
      bool hasError,
      bool isAnnualIncomeInvalid,
      bool isMonthlyCostsIinvalid,
    )?
    failed,
    TResult Function(FinancialWellnessScore score)? completed,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScoreInputInitialState value) idle,
    required TResult Function(ScoreInputLoading value) loading,
    required TResult Function(ScoreCalculationFailed value) failed,
    required TResult Function(ScoreCompleted value) completed,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ScoreInputInitialState value)? idle,
    TResult? Function(ScoreInputLoading value)? loading,
    TResult? Function(ScoreCalculationFailed value)? failed,
    TResult? Function(ScoreCompleted value)? completed,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScoreInputInitialState value)? idle,
    TResult Function(ScoreInputLoading value)? loading,
    TResult Function(ScoreCalculationFailed value)? failed,
    TResult Function(ScoreCompleted value)? completed,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class ScoreInputInitialState extends ScoreInputState {
  factory ScoreInputInitialState() = _$ScoreInputInitialStateImpl;
  ScoreInputInitialState._() : super._();
}

/// @nodoc
abstract class _$$ScoreInputLoadingImplCopyWith<$Res> {
  factory _$$ScoreInputLoadingImplCopyWith(
    _$ScoreInputLoadingImpl value,
    $Res Function(_$ScoreInputLoadingImpl) then,
  ) = __$$ScoreInputLoadingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({UserFinancialData data});

  $UserFinancialDataCopyWith<$Res> get data;
}

/// @nodoc
class __$$ScoreInputLoadingImplCopyWithImpl<$Res>
    extends _$ScoreInputStateCopyWithImpl<$Res, _$ScoreInputLoadingImpl>
    implements _$$ScoreInputLoadingImplCopyWith<$Res> {
  __$$ScoreInputLoadingImplCopyWithImpl(
    _$ScoreInputLoadingImpl _value,
    $Res Function(_$ScoreInputLoadingImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ScoreInputState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? data = null}) {
    return _then(
      _$ScoreInputLoadingImpl(
        data:
            null == data
                ? _value.data
                : data // ignore: cast_nullable_to_non_nullable
                    as UserFinancialData,
      ),
    );
  }

  /// Create a copy of ScoreInputState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserFinancialDataCopyWith<$Res> get data {
    return $UserFinancialDataCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$ScoreInputLoadingImpl extends ScoreInputLoading {
  _$ScoreInputLoadingImpl({required this.data}) : super._();

  @override
  final UserFinancialData data;

  @override
  String toString() {
    return 'ScoreInputState.loading(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ScoreInputLoadingImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  /// Create a copy of ScoreInputState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ScoreInputLoadingImplCopyWith<_$ScoreInputLoadingImpl> get copyWith =>
      __$$ScoreInputLoadingImplCopyWithImpl<_$ScoreInputLoadingImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function(UserFinancialData data) loading,
    required TResult Function(
      UserFinancialData data,
      bool hasError,
      bool isAnnualIncomeInvalid,
      bool isMonthlyCostsIinvalid,
    )
    failed,
    required TResult Function(FinancialWellnessScore score) completed,
  }) {
    return loading(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function(UserFinancialData data)? loading,
    TResult? Function(
      UserFinancialData data,
      bool hasError,
      bool isAnnualIncomeInvalid,
      bool isMonthlyCostsIinvalid,
    )?
    failed,
    TResult? Function(FinancialWellnessScore score)? completed,
  }) {
    return loading?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function(UserFinancialData data)? loading,
    TResult Function(
      UserFinancialData data,
      bool hasError,
      bool isAnnualIncomeInvalid,
      bool isMonthlyCostsIinvalid,
    )?
    failed,
    TResult Function(FinancialWellnessScore score)? completed,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScoreInputInitialState value) idle,
    required TResult Function(ScoreInputLoading value) loading,
    required TResult Function(ScoreCalculationFailed value) failed,
    required TResult Function(ScoreCompleted value) completed,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ScoreInputInitialState value)? idle,
    TResult? Function(ScoreInputLoading value)? loading,
    TResult? Function(ScoreCalculationFailed value)? failed,
    TResult? Function(ScoreCompleted value)? completed,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScoreInputInitialState value)? idle,
    TResult Function(ScoreInputLoading value)? loading,
    TResult Function(ScoreCalculationFailed value)? failed,
    TResult Function(ScoreCompleted value)? completed,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class ScoreInputLoading extends ScoreInputState {
  factory ScoreInputLoading({required final UserFinancialData data}) =
      _$ScoreInputLoadingImpl;
  ScoreInputLoading._() : super._();

  UserFinancialData get data;

  /// Create a copy of ScoreInputState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ScoreInputLoadingImplCopyWith<_$ScoreInputLoadingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ScoreCalculationFailedImplCopyWith<$Res> {
  factory _$$ScoreCalculationFailedImplCopyWith(
    _$ScoreCalculationFailedImpl value,
    $Res Function(_$ScoreCalculationFailedImpl) then,
  ) = __$$ScoreCalculationFailedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({
    UserFinancialData data,
    bool hasError,
    bool isAnnualIncomeInvalid,
    bool isMonthlyCostsIinvalid,
  });

  $UserFinancialDataCopyWith<$Res> get data;
}

/// @nodoc
class __$$ScoreCalculationFailedImplCopyWithImpl<$Res>
    extends _$ScoreInputStateCopyWithImpl<$Res, _$ScoreCalculationFailedImpl>
    implements _$$ScoreCalculationFailedImplCopyWith<$Res> {
  __$$ScoreCalculationFailedImplCopyWithImpl(
    _$ScoreCalculationFailedImpl _value,
    $Res Function(_$ScoreCalculationFailedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ScoreInputState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? hasError = null,
    Object? isAnnualIncomeInvalid = null,
    Object? isMonthlyCostsIinvalid = null,
  }) {
    return _then(
      _$ScoreCalculationFailedImpl(
        data:
            null == data
                ? _value.data
                : data // ignore: cast_nullable_to_non_nullable
                    as UserFinancialData,
        hasError:
            null == hasError
                ? _value.hasError
                : hasError // ignore: cast_nullable_to_non_nullable
                    as bool,
        isAnnualIncomeInvalid:
            null == isAnnualIncomeInvalid
                ? _value.isAnnualIncomeInvalid
                : isAnnualIncomeInvalid // ignore: cast_nullable_to_non_nullable
                    as bool,
        isMonthlyCostsIinvalid:
            null == isMonthlyCostsIinvalid
                ? _value.isMonthlyCostsIinvalid
                : isMonthlyCostsIinvalid // ignore: cast_nullable_to_non_nullable
                    as bool,
      ),
    );
  }

  /// Create a copy of ScoreInputState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserFinancialDataCopyWith<$Res> get data {
    return $UserFinancialDataCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$ScoreCalculationFailedImpl extends ScoreCalculationFailed {
  _$ScoreCalculationFailedImpl({
    required this.data,
    this.hasError = false,
    this.isAnnualIncomeInvalid = false,
    this.isMonthlyCostsIinvalid = false,
  }) : super._();

  @override
  final UserFinancialData data;

  /// Global kind of error, during data fetching for instance.
  @override
  @JsonKey()
  final bool hasError;

  /// Field errors
  @override
  @JsonKey()
  final bool isAnnualIncomeInvalid;
  @override
  @JsonKey()
  final bool isMonthlyCostsIinvalid;

  @override
  String toString() {
    return 'ScoreInputState.failed(data: $data, hasError: $hasError, isAnnualIncomeInvalid: $isAnnualIncomeInvalid, isMonthlyCostsIinvalid: $isMonthlyCostsIinvalid)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ScoreCalculationFailedImpl &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.hasError, hasError) ||
                other.hasError == hasError) &&
            (identical(other.isAnnualIncomeInvalid, isAnnualIncomeInvalid) ||
                other.isAnnualIncomeInvalid == isAnnualIncomeInvalid) &&
            (identical(other.isMonthlyCostsIinvalid, isMonthlyCostsIinvalid) ||
                other.isMonthlyCostsIinvalid == isMonthlyCostsIinvalid));
  }

  @override
  int get hashCode => Object.hash(
    runtimeType,
    data,
    hasError,
    isAnnualIncomeInvalid,
    isMonthlyCostsIinvalid,
  );

  /// Create a copy of ScoreInputState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ScoreCalculationFailedImplCopyWith<_$ScoreCalculationFailedImpl>
  get copyWith =>
      __$$ScoreCalculationFailedImplCopyWithImpl<_$ScoreCalculationFailedImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function(UserFinancialData data) loading,
    required TResult Function(
      UserFinancialData data,
      bool hasError,
      bool isAnnualIncomeInvalid,
      bool isMonthlyCostsIinvalid,
    )
    failed,
    required TResult Function(FinancialWellnessScore score) completed,
  }) {
    return failed(
      data,
      hasError,
      isAnnualIncomeInvalid,
      isMonthlyCostsIinvalid,
    );
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function(UserFinancialData data)? loading,
    TResult? Function(
      UserFinancialData data,
      bool hasError,
      bool isAnnualIncomeInvalid,
      bool isMonthlyCostsIinvalid,
    )?
    failed,
    TResult? Function(FinancialWellnessScore score)? completed,
  }) {
    return failed?.call(
      data,
      hasError,
      isAnnualIncomeInvalid,
      isMonthlyCostsIinvalid,
    );
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function(UserFinancialData data)? loading,
    TResult Function(
      UserFinancialData data,
      bool hasError,
      bool isAnnualIncomeInvalid,
      bool isMonthlyCostsIinvalid,
    )?
    failed,
    TResult Function(FinancialWellnessScore score)? completed,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed(
        data,
        hasError,
        isAnnualIncomeInvalid,
        isMonthlyCostsIinvalid,
      );
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScoreInputInitialState value) idle,
    required TResult Function(ScoreInputLoading value) loading,
    required TResult Function(ScoreCalculationFailed value) failed,
    required TResult Function(ScoreCompleted value) completed,
  }) {
    return failed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ScoreInputInitialState value)? idle,
    TResult? Function(ScoreInputLoading value)? loading,
    TResult? Function(ScoreCalculationFailed value)? failed,
    TResult? Function(ScoreCompleted value)? completed,
  }) {
    return failed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScoreInputInitialState value)? idle,
    TResult Function(ScoreInputLoading value)? loading,
    TResult Function(ScoreCalculationFailed value)? failed,
    TResult Function(ScoreCompleted value)? completed,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed(this);
    }
    return orElse();
  }
}

abstract class ScoreCalculationFailed extends ScoreInputState {
  factory ScoreCalculationFailed({
    required final UserFinancialData data,
    final bool hasError,
    final bool isAnnualIncomeInvalid,
    final bool isMonthlyCostsIinvalid,
  }) = _$ScoreCalculationFailedImpl;
  ScoreCalculationFailed._() : super._();

  UserFinancialData get data;

  /// Global kind of error, during data fetching for instance.
  bool get hasError;

  /// Field errors
  bool get isAnnualIncomeInvalid;
  bool get isMonthlyCostsIinvalid;

  /// Create a copy of ScoreInputState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ScoreCalculationFailedImplCopyWith<_$ScoreCalculationFailedImpl>
  get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ScoreCompletedImplCopyWith<$Res> {
  factory _$$ScoreCompletedImplCopyWith(
    _$ScoreCompletedImpl value,
    $Res Function(_$ScoreCompletedImpl) then,
  ) = __$$ScoreCompletedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({FinancialWellnessScore score});
}

/// @nodoc
class __$$ScoreCompletedImplCopyWithImpl<$Res>
    extends _$ScoreInputStateCopyWithImpl<$Res, _$ScoreCompletedImpl>
    implements _$$ScoreCompletedImplCopyWith<$Res> {
  __$$ScoreCompletedImplCopyWithImpl(
    _$ScoreCompletedImpl _value,
    $Res Function(_$ScoreCompletedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ScoreInputState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? score = null}) {
    return _then(
      _$ScoreCompletedImpl(
        score:
            null == score
                ? _value.score
                : score // ignore: cast_nullable_to_non_nullable
                    as FinancialWellnessScore,
      ),
    );
  }
}

/// @nodoc

class _$ScoreCompletedImpl extends ScoreCompleted {
  _$ScoreCompletedImpl({required this.score}) : super._();

  @override
  final FinancialWellnessScore score;

  @override
  String toString() {
    return 'ScoreInputState.completed(score: $score)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ScoreCompletedImpl &&
            (identical(other.score, score) || other.score == score));
  }

  @override
  int get hashCode => Object.hash(runtimeType, score);

  /// Create a copy of ScoreInputState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ScoreCompletedImplCopyWith<_$ScoreCompletedImpl> get copyWith =>
      __$$ScoreCompletedImplCopyWithImpl<_$ScoreCompletedImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function(UserFinancialData data) loading,
    required TResult Function(
      UserFinancialData data,
      bool hasError,
      bool isAnnualIncomeInvalid,
      bool isMonthlyCostsIinvalid,
    )
    failed,
    required TResult Function(FinancialWellnessScore score) completed,
  }) {
    return completed(score);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function(UserFinancialData data)? loading,
    TResult? Function(
      UserFinancialData data,
      bool hasError,
      bool isAnnualIncomeInvalid,
      bool isMonthlyCostsIinvalid,
    )?
    failed,
    TResult? Function(FinancialWellnessScore score)? completed,
  }) {
    return completed?.call(score);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function(UserFinancialData data)? loading,
    TResult Function(
      UserFinancialData data,
      bool hasError,
      bool isAnnualIncomeInvalid,
      bool isMonthlyCostsIinvalid,
    )?
    failed,
    TResult Function(FinancialWellnessScore score)? completed,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(score);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ScoreInputInitialState value) idle,
    required TResult Function(ScoreInputLoading value) loading,
    required TResult Function(ScoreCalculationFailed value) failed,
    required TResult Function(ScoreCompleted value) completed,
  }) {
    return completed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ScoreInputInitialState value)? idle,
    TResult? Function(ScoreInputLoading value)? loading,
    TResult? Function(ScoreCalculationFailed value)? failed,
    TResult? Function(ScoreCompleted value)? completed,
  }) {
    return completed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ScoreInputInitialState value)? idle,
    TResult Function(ScoreInputLoading value)? loading,
    TResult Function(ScoreCalculationFailed value)? failed,
    TResult Function(ScoreCompleted value)? completed,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(this);
    }
    return orElse();
  }
}

abstract class ScoreCompleted extends ScoreInputState {
  factory ScoreCompleted({required final FinancialWellnessScore score}) =
      _$ScoreCompletedImpl;
  ScoreCompleted._() : super._();

  FinancialWellnessScore get score;

  /// Create a copy of ScoreInputState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ScoreCompletedImplCopyWith<_$ScoreCompletedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
